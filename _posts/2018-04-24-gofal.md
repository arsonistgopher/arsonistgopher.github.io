---
layout: post
title: goFAL - File Abstraction in Go
categories: [golang]
tags: [golang]
fullview: false
excerpt_separator: <!--more-->
comments: true
---

When writing scripts that create or manipulate file and directories, it's all too easy to get lost using `chmod` and `chdir` operating system directives. Move here, do that, change this, write that. Bah. Unless you track very carefully what directory your script is working in, it's all too easy to get lost. There is always an easier way.

<!--more-->

After a quick hunt around using my Google powers and checking out various Go sites, I didn't find what I was looking for. That might have been due to not looking for the right thing or using the correct keywords, but find it I did not. Therefore, the next logical step was to build what I required, then consume. The result may prove useful.

__*How do we use it?*__
1.  Build a root node
2.  Add directories or files using the concept of parents
3.  Generate the tree
4.  Manipulate the file contents
5.  Generate hashes
6.  Set permissions
7.  Use

Steps 1 through 6 rely on exported package level functions with package level constants for ease of use.

__*What does goFAL stand for?*__
goFAL = `Go File Abstraction Layer`.

#### Example

The example makes use of Godeps, so restore the dependencies with ease and build.

{% highlight bash %}
cd exampleCode
godep restore
go build
./exampleCode
{% endhighlight %}

This assumes a working Go toolchain install. I always work with the latest stable. Simples.

This example involves:
1.  Create root directory
2.  Create content directory
3.  Create file in root directory
4.  Create file in content directory

Each file and directory has permissions associated with them. Hashes will only be calculated for files.

Source code is [here](https://github.com/arsonistgopher/gofal.git).

{% highlight go %}
/*
Copyright 2018 David Gee
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"fmt"
	"os"

	"github.com/Sirupsen/logrus"
	"github.com/arsonistgopher/glog"
	gf "github.com/arsonistgopher/gofal"
)

func checkerr(l glog.Logger, e error) {
	if e != nil {
		l.Error(e)
	}
}

func main() {

	// De-coupled logging
	logger := glog.Logger{Name: "fds"}
	// Inject logrus
	logger.LoggingBase = logrus.New()

	logger.Info("--- Welcome to the FDS Demo ---")

	// Create root node called 'build'
	build, err := gf.BuildRoot("build", os.ModePerm)
	checkerr(logger, err)

	// Add a content directory called 'content' and set the permissions
	content, err := gf.BuildNode(build, "content", os.ModePerm, gf.DIR)
	checkerr(logger, err)

	// Add a file under the build directory called 'content1' and set perms
	file1, err := gf.BuildNode(build, "content1.txt", 0444, gf.FILE)
	checkerr(logger, err)

	// Add a file under the content directory called 'content2' and set perms
	file2, err := gf.BuildNode(content, "content2.txt", 0444, gf.FILE)
	checkerr(logger, err)

	// Generate file tree on disk
	err = gf.Generate(build)
	checkerr(logger, err)

	// Insert content
	file1Content := []byte("Hello from IPEngineer once.")
	file2Content := []byte("Hello from IPEngineer twice.")
	err = gf.FileWrite(file1, file1Content)
	checkerr(logger, err)
	err = gf.FileWrite(file2, file2Content)
	checkerr(logger, err)

	// Create hashes using the build root as an anchor
	err = gf.BuildHashes(build)
	checkerr(logger, err)

	// Set permissions (post writing) as per tree data
	err = gf.SetPerms(build)
	checkerr(logger, err)

	// Uncomment line below to print build info
	// fmt.Println(build.String())

	// Because we have a String() method, we can also call print directly. Uncomment line below.
	// fmt.Print(build)

	// This builds our stringfied object tree
	fmt.Println(build.TreeString())
}
{% endhighlight %}

Note, it's possible to print out string representations of the tree nodes in a couple of ways which includes the full tree with hierarchical indentations. Two examples below. TreeString will print the tree from the perspective of the node that `TreeString()` is being called on.

{% highlight bash %}
fmt.Println(<node>)
fmt.Println(<node>.TreeString())
{% endhighlight %}

Tree output as follows:

__Dir/File__                __Perm(Octal)__
{% highlight bash %}
build                   0755
├── content             0777
│   └── content2.txt    0444
└── content1.txt        0444
{% endhighlight %}

#### ToDo

1.  Write some tests
2.  Add signature capabilities for specific branches or the tree

#### The Burn Down

This made my life easier!

#### Contributing

Fork and work on master. Create PR and I'll review.
